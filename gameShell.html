<body style=margin:0>
<canvas id=a>
<script>
// initialize 2D canvas (c)
// initialize game state (s)
// initialize keys states (u,r,d,l for directions, k for all the keyboard)
c=a.getContext`2d`,k=[u=r=d=l=s=0]

// variables for touch or mouse movement
let startX, startY, endX, endY;
//global variables
let words = 'swipe'

// update u,l,d,r globals when an arrow key/wasd/zqsd is pressed or released
// update k[keyCode] if any other key is pressed/released
onkeydown=onkeyup=e=>k[e.which]=self['lld*rlurdu'[e.which%32%17]]=e.type[5]

// start game loop (60fps)
setInterval(e=>{
  a.width=innerWidth,a.height=innerHeight;
  // Draw a custom dashed border
  c.setLineDash([10, 5]); // [dash length, gap length]
  c.lineWidth = 10;        // Border thickness
  c.strokeStyle = 'black'; // Border color
  
  // Draw the border inside the canvas
  c.strokeRect(1, 1, a.width - 2, a.height - 2); // Adjust for border width
  
   c.font="84px sans-serif",c.fillText(words,50,150);
  
  switch(s){
    case 0: // ex: draw title screen
    case 1: // ex: draw menu screen
    case 2: // ex: draw game board
    case 3: // ex: draw game over screen
  }
},16)

// handle click/touch events
onclick=e=>{
  x=e.pageX;y=e.pageY;
  switch(s){
    case 0: // react to clicks on screen 0
    case 1: // react to clicks on screen 1
    case 2: // react to clicks on screen 2
    case 3: // react to clicks on screen 3
  }
}

// handle touch start
a.addEventListener('touchstart', e => {
  e.preventDefault(); // Prevent default touch behavior
  const touch = e.touches[0];
  startX = touch.pageX;
  startY = touch.pageY;
});

// handle touch end
a.addEventListener('touchend', e => {
  e.preventDefault(); // Prevent default touch behavior
  const touch = e.changedTouches[0];
  endX = touch.pageX;
  endY = touch.pageY;

  // detect swipe direction (left, right, up, down)
  let dx = endX - startX;
  let dy = endY - startY;

  // threshold to detect swipes
  const threshold = 30;

  // horizontal swipe (left or right)
  if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > threshold) {
    if (dx > 0) {
      r = 1;
      words = 'Swiped right';
    } else {
      l = 1;
      words = 'Swiped left';
    }
  }

  // vertical swipe (up or down)
  if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > threshold) {
    if (dy > 0) {
      d = 1;
      words = 'Swiped down';
    } else {
      u = 1;
      words = 'Swiped up';
    }
  }
});

// handle mouse start and end for desktop
a.addEventListener('mousedown', e => {
  startX = e.pageX;
  startY = e.pageY;
});

a.addEventListener('mouseup', e => {
  endX = e.pageX;
  endY = e.pageY;

  // detect swipe direction (same logic as above)
  let dx = endX - startX;
  let dy = endY - startY;
  const threshold = 30;

  if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > threshold) {
    if (dx > 0) words = 'Swiped right';
    else words = 'Swiped left';
  }

  if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > threshold) {
    if (dy > 0) words = 'Swiped down';
    else words = 'Swiped up';
  }
});
</script>
</body>
